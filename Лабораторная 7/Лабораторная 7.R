#1. Nt при фиксированном значении t

set.seed(123)  

t = 50  
λ = 2  
n = 1000  
N = integer(n) #число страховых случаев

for (i in 1:n) {
  τ = numeric()  #моменты времени между страховыми случаями
  k = 0
  while (sum(τ) < t) {
    τ[length(τ) + 1] = rexp(1, λ)  #время до следующего страхового случая
    k = k + 1
  }
  N[i] = k
}

hist(N, freq = FALSE, main = "Гистограмма", xlab = "Число страховых случаев", ylab = "Плотность вероятности", col = "lightblue")

#функция вероятности распределения Пуассона
Poisson = function(k) {
  (λ * t)^k / factorial(k) * exp(-λ * t)
}

curve(Poisson, from = 0, to = max(N), add = TRUE, col = "red")
legend("topleft", legend = c("Гистограмма", "Функция вероятности Пуассона"), fill = c("lightblue", "red"), cex = 0.5)

#3. Реализация процесса (12) (капитал страховой компании)

t_max = 50
U0 = 50  #начальный капитал

U1 = U2 = numeric()  #значения капитала 
τ1 = τ2 = T1 = T2 = numeric()  #время и моменты страховых случаев

#а) условие выполняется
c1 = 1
λ1 = 0.3
μ1 = 2

#b) условие не выполняется
c2 = 1
λ2 = 0.9
μ2 = 10

ρ1 = c1 / (λ1 * μ1) - 1; ρ1  # > 0, вероятность разорения < 1
ρ2 = c2 / (λ2 * μ2) - 1; ρ2  # < 0, вероятность разорения > 1

par(mfrow = c(2, 1))

#a)
i = 2
U1[1] = U0
T1[1] = 0
while (T1[i - 1] < t_max) {
  τ1[i] = rexp(1, λ1)
  T1[i] = T1[i - 1] + τ1[i]
  X = rexp(1, 1 / μ1)
  U1[i] = U1[i - 1] + c1 * τ1[i] - X
  i = i + 1
}
plot(T1, U1, type = 'l', col = "red", main = "ρ > 0:")

#b)
i = 2
U2[1] = U0
T2[1] = 0
while (T2[i - 1] < t_max) {
  τ2[i] = rexp(1, λ2)
  T2[i] = T2[i - 1] + τ2[i]
  X = rexp(1, 1 / μ2)
  U2[i] = U2[i - 1] + c2 * τ2[i] - X
  i = i + 1
}
plot(T2, U2, type = 'l', col = "red", main = "ρ < 0:")

# При выполнении условий капитал растет, вероятность разорения низкая,
# при невыполнении - уменьшается, высокая вероятность разорения

#4. Выборочная вероятность разорения при заданных параметрах

t_max = 1000; c = 1; λ = 0.3
μ = 3; U0 = 100; N = 1000
sum_r = 0
U = T = numeric()

for (i in 1:N) {
  U[1] = U0
  T[1] = rexp(1, λ)
  j = 0 #индикатор разорения
  i = 2 
  while (T[i - 1] < t_max) {
    T[i] = T[i - 1] + rexp(1, λ)
    X = rexp(1, 1 / μ) #случайный размер страховой выплаты
    U[i] = U[i - 1] + c * T[i - 1] - X
    if (U[i] < 0) {
      j = 1 #если капитал отрицательный, устанавливаем индикатор разорения
    }
    i = i + 1
  }
  sum_r = sum_r + j
}
sum_r #общее количество разорений

#выборочная вероятность разорения фирмы
Ψ_hat = (1 / N) * sum_r

#проверка условия 16
ρ = c / (λ * μ) - 1
Ψ = exp(-ρ * U0 / (μ * (1 + ρ)))

Ψ_hat
Ψ
# Ψ_hat < Ψ, sum_r равна нулю, что означает, что у фирмы не было разорений
